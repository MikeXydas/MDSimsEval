import MDAnalysis
import mdtraj as md_traj
from MDAnalysis.analysis.rms import RMSF
from MDAnalysis.analysis import contacts
import MDAnalysis.analysis.pca as pca

import logging
import re
import numpy as np

class AnalysisActor:
    """
    The AnalysisActor object inputs a single topology and trajectory and performs the analysis
    A full list of input formats: https://www.mdanalysis.org/docs/documentation_pages/coordinates/init.html#supported-coordinate-formats

    Args:
        topology (str): The topology filepath (.pdb, .gro etc)
        trajectory (str): The trajectory filepath (.xtc etx)
        drug_name (str): The name of the agonist or antagonist

    Attributes:
        uni: The universe of atoms created by MDAnalysis tool
        mdtraj: The trajectory of atoms created by MDTraj tool (currently not used)
        drug_name (str): The drug name
        rg_res (List[double]): Radius of gyration of each frame
        rmsf_res (List[double]): RMSF of each residue
        pca_res (Object: MDAnalysis.analysis.pca.PCA): Object containing eigenvectors and eigenvalues
                                                       of CA atoms covariance matrix

        sasa_res (np.array[2, #frames]):  The calculation currently is performed outside of the pipeline
                                          using gromacs. MDTraj offers an algorithm for calculating SASA
                                          but is computationally intensive and cannot run on my laptop

        hbonds (np.array[#frames, #hbonds_of_frame, 3]):    A list containing the atom indices involved in
                                                            each of the identified hydrogen bonds at each frame.
                                                            Each element in the list is an array where each row contains
                                                            three integer indices, (d_i, h_i, a_i),
                                                            such that d_i is the index of the donor atom,
                                                            h_i the index of the hydrogen atom,
                                                            and a_i the index of the acceptor atom involved
                                                            in a hydrogen bond which occurs in that frame.

        salt_bridges (MDAnalysis.analysis.contacts.Contacts): An object containing (.timeseries) the fraction of salt
                                                              bridges we have in reference with the 1st frame
    """

    def __init__(self, topology, trajectory, drug_name, sasa_file=""):
        self.uni = MDAnalysis.Universe(topology, trajectory)
        self.mdtraj = md_traj.load(trajectory, top=topology)
        self.drug_name = drug_name
        self.rg_res = None
        self.rmsf_res = None
        self.pca_res = None
        self.hbonds = None
        self.salt_bridges = None
        self.sasa_res = self.__read_sasa_file(sasa_file) if sasa_file != "" else np.arange(1)

    def __read_sasa_file(self, sasa_filepath):
        '''
        Private method that helps us parse the sasa.xvg file generated by `gmx sasa -f trajectory.xtc -s topology.tpr -o sasa.xvg`
        and and stores them into a numpy array

        Args:
            sasa_filepath (str): Filepath of the .xvg file to read

        Returns:
            np.array[2, #frames], eg [[0, 1, 2, ... , n], [SASA0, SASA1, SASA2, ..., SASAn]]
        '''
        sasa_list = []
        p = re.compile('\s+([0-9\.]*)\s+([0-9\.]*)\\n')  # RegEx to extract the frame, SASA pair of each frame

        with open(sasa_filepath) as fp:
            lines = fp.readlines()
            for line in lines:
                if line[0] != '#' and line[0] != '@':  # Ignore the GROMACS comment lines
                    m = p.match(line)
                    sasa_list.append([m.group(1), m.group(2)])  # Group1: Frame, Group2: SASA

        sasa_list_arr = np.array(sasa_list).T.astype('float64')  # Cast to numpy array and transpose
        return sasa_list_arr

    def info(self):
        """ Prints basic info of the universe of atoms """
        print(f'\n<<< Info of {self.drug_name} >>>')
        print(f'\tNumber of Frames: {len(self.uni.trajectory)}')
        print(f'\tNumber of Atoms: {len(self.uni.atoms)}')
        print(f'\tNumber of Residues: {len(self.uni.residues)}')

    def get_frames_number(self):
        """ Returns the number of frames of the trajectory """
        return len(self.uni.trajectory)

    def perform_analysis(self, metrics=[]):
        """
        Runs the analysis methods for calculating the metrics specified by metrics argument

        Args:
            metrics (List[str]): A list of the metrics to be calculated. Available:
                                 Empty List []: All of the available metrics will be calculated (default)
                                 'Rg': Radius of Gyration
                                 'RMSF': Root Mean Square Fluctuations
                                 'SASA': Solvent Accessible Surface Area
                                 'PCA': Principal Component Analysis
                                 'Hbonds': Hydrogen Bonds
                                 'Salt': Calculate number of salt bridges
        """

        # Calculate Radius of Gyration as time progresses
        if "Rg" in metrics or len(metrics) == 0:
            self.rg_res = []
            for frame in self.uni.trajectory:
                self.rg_res.append(self.uni.atoms.radius_of_gyration())

        # Calculate Solvent Accessible Surface Area
        if "SASA" in metrics or len(metrics) == 0:
            # self.sasa_res = md_traj.shrake_rupley(self.mdtraj) # Cannot calculate on my laptop
            if self.sasa_res.shape == (1,):
                logging.warning(f'No sasa.xvg generated by GROMACS was found in the {self.drug_name} directory')

        # Calculate Root Mean Square Fluctuation
        if "RMSF" in metrics or len(metrics) == 0:
            # TODO: Look more into alignment step
            self.rmsf_res = RMSF(self.uni.atoms).run()

        # Perform PCA on the CA atoms
        if "PCA" in metrics or len(metrics) == 0:
            self.pca_res = pca.PCA(self.uni, select='name CA')
            self.pca_res.run()

        # Calculate the Hydrogen Bonds using wernet_nilsson algorithm from MDTraj
        if "Hbonds" in metrics or len(metrics) == 0:
            self.hbonds = md_traj.wernet_nilsson(self.mdtraj, periodic=False)

        # Calculate the Salt Bridges
        if "Salt" in metrics or len(metrics) == 0:
            # Salt bridges will typically be formed next to
            # Lys or Arg as the bases and Asp or Glu as the acids
            sel_basic = "(resname ARG LYS) and (name NH* NZ)"
            sel_acidic = "(resname ASP GLU) and (name OE* OD*)"

            # Give as reference structure the 1st frame
            acidic = self.uni.select_atoms(sel_acidic)
            basic = self.uni.select_atoms(sel_basic)

            # We use as a distance cutoff for a salt bridge: 4.0
            self.salt_bridges = contacts.Contacts(self.uni,
                                                  selection=(sel_acidic, sel_basic),
                                                  refgroup=(acidic, basic), radius=4.0)
            self.salt_bridges.run()

    ''' 
    Getters of attributes

        Raises: TypeError when get is attempted on not calculated metric
    '''

    def get_radius_of_gyration(self):
        if self.rg_res is None:
            logging.error("Radius of Gyration was not calculated")
            raise TypeError
        else:
            return self.rg_res

    def get_rmsf(self):
        if self.rmsf_res is None:
            logging.error("RMSF was not calculated")
            raise TypeError
        else:
            return self.rmsf_res

    def get_pca(self):
        if self.pca_res is None:
            logging.error("PCA of simulation was not calculated")
            raise TypeError
        else:
            return self.pca_res

    def get_hbonds(self):
        if self.hbonds is None:
            logging.error("Hydrogen bonds were not calculated")
            raise TypeError
        else:
            return self.hbonds

    def get_salt_bridges(self):
        if self.salt_bridges is None:
            logging.error("Salt bridges were not calculated")
            raise TypeError
        else:
            return self.salt_bridges

    def get_sasa(self):
        if self.sasa_res.shape == (1,):
            logging.error("SASA was not calculated")
            raise TypeError
        else:
            return self.sasa_res
